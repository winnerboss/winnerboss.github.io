<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java实现 LeetCode 18. 四数之和]]></title>
    <url>%2F2019%2F06%2F08%2Fleetcode018%2F</url>
    <content type="text"><![CDATA[18. 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路： 这道题在第15题的基础上又多了一个数字，那么按照之前的思路，我们就可以实现O(n3)的复杂度，前两个数用循环遍历，后两个数使用双指针查找。 代码： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) return list; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3 &amp;&amp; nums[i] &lt;= target / 4; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if (nums[i] + nums[nums.length - 3] + nums[nums.length - 2] + nums[nums.length - 1] &lt; target) continue; for (int j = i + 1; j &lt; nums.length - 2 &amp;&amp; nums[j] &lt;= (target - nums[i]) / 3; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; if (nums[j] + nums[nums.length - 2] + nums[nums.length - 1] &lt; target - nums[i]) continue; int k = j + 1; int n = nums.length - 1; while (k &lt; n) &#123; if (nums[k] + nums[n] == target - nums[j] - nums[i]) &#123; List&lt;Integer&gt; L = new ArrayList&lt;&gt;(); L.add(nums[i]); L.add(nums[j]); L.add(nums[k]); L.add(nums[n]); list.add(L); k++; while (k &lt; n &amp;&amp; nums[k] == nums[k - 1]) k++; n--; while (k &lt; n &amp;&amp; nums[n] == nums[n + 1]) n--; &#125; else if (nums[k] + nums[n] &lt; target - nums[j] - nums[i]) &#123; k++; &#125; else &#123; n--; &#125; &#125; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java实现 LeetCode 16. 三数之和]]></title>
    <url>%2F2019%2F06%2F08%2Fleetcode016%2F</url>
    <content type="text"><![CDATA[16. 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路： 这道题的思路和第15题如出一辙，唯一不同的是需要一个变量记录离目标值最近的距离，然后实时保存最小距离的情况就可以了。 代码： 123456789101112131415161718192021222324class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int max = Integer.MAX_VALUE;//与目标值的距离 int r = 0;//保存最接近的三数和 for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int j = i + 1;//双指针 int n = nums.length - 1;//双指针 while (j &lt; n) &#123; int sum = nums[i] + nums[j] + nums[n]; int t = Math.abs(target - sum); if (t &lt; max) &#123; max = t; r = sum; &#125; if (sum &lt; target) j++; else if (sum == target) return sum;//题目中假定只有一个答案，所以若结果正好等于目标值，则直接返回 else n--; &#125; &#125; return r; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java实现 LeetCode 15. 三数之和]]></title>
    <url>%2F2019%2F04%2F11%2Fleetcode015%2F</url>
    <content type="text"><![CDATA[​ 刷了leetcode一个多月的题，我终于刷完了所有简单难度的题目，开始了奋战中等难度的旅程。但在一开始我就遇到了阻碍——我遇到了一系列的关于数组的目标值查找和求排列组合的问题。在解决完这一系列问题之后，我决定总结一下这些题目的思路，分享给大家一些自己的收获。 ​ 第一篇文章先从“三数之和”这道题开始说起。 15. 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路： 首先，作为一名经验丰富的程序员，你的第一反应绝对应该是：不要使用O(n3)的三重循环来求解！（太蠢了） 那应该怎么处理呢？ 相信大家都完成了leetcode中的第一题1. 两数之和——其方法是使用Hash表来实现 O(n)的时间复杂度。对于三数之和，如果先选定一个数a，再用第一题的方法去查找剩下的两个数b,c之和是否为0-a，那么算法的时间复杂度就可以达到O(n2)。但是这两道题不一样的地方在于，在第一题中只存在一个答案并且数组中没有重复的数字。若想用到数组中重复的数字，则需要记录每个数字出现的次数，这至少要用到Map或者格外的数组来标记；计算结果的同时还需要考虑如何去重。所以此题仅仅依靠哈希表无法直接得出结果。 那么，现在我们需要考虑的问题就是，如何利用重复的数字以及如何去重。能够同时解决这两个问题的方法就是：将数组排序后，用双指针进行查找。 排序是解决大多数去重问题的常用方法，在排序后进行双指针查找某个数，只需要遍历一遍数组。排序之后对于每个元素n，我们都把它当做符合条件的三个数中最小的那个，从而在排在n后面的元素集合中去寻找两个和为0-n的元素。因为剩下的元素是排好序的，我们可以用两个指针分别从n的后一位、数组的末尾开始向中间移动。若两指针元素和小于0-n，则前面的指针向后移，若两指针元素和大于0-n，则后面的指针向前移。若找到符合条件的三个元素则加入到返回结果集中，之后继续进行判断，若下一个元素与上一个已完成判断的元素相同时就直接跳过，这样就实现了去重的操作。 代码： 12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; r = new ArrayList&lt;&gt;(); Arrays.sort(nums); int one = 0; while (one &lt; nums.length - 2) &#123; int target = 0 - nums[one]; int two = one + 1; int three = nums.length - 1; while (two &lt; three) &#123; int sum = nums[two] + nums[three]; if (sum &gt; target) &#123; three--; &#125; else if (sum &lt; target) &#123; two++; &#125; else &#123; r.add(Arrays.asList(nums[one], nums[two], nums[three])); while (++two &lt; three &amp;&amp; nums[two] == nums[two - 1]) ;// 去重 &#125; &#125; while (++one &lt; nums.length - 2 &amp;&amp; nums[one] == nums[one - 1]) ;// 去重 &#125; return r; &#125;&#125; 时间复杂度为O(n2)。将0换为任意的数字n，即可应对所有 a + b + c = n时的情况。 那么问题来了：对于这道题里的和为0，有没有什么特殊的求解算法使运算更快呢？ 分析：当三个数都为0时，符合题意；当三个数不全为0时，其中必然会有一个正数和一个负数。所以可以把原数组中的正数与负数分别取出，分为正数数组和负数数组两个数组。将两个数组排序后，从正数数组中取数字a，负数数组中取数字b，再查询原数组中有没有0-a-b的数（可以使用map映射表的结构保存原数组元素进行查找，并且设定a&gt;=c&gt;=b可以实现去重）。由于结果中可能用到重复的数字，还需要记录每个数字出现的次数（使用数组即可同时记录出现次数）。 下面贴出leetcode答案中运算时间最短的大神代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (nums.length &lt; 3) return Collections.emptyList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int minValue = Integer.MAX_VALUE; int maxValue = Integer.MIN_VALUE; int negSize = 0; int posSize = 0; int zeroSize = 0; for (int v : nums) &#123;//遍历原数组 if (v &lt; minValue) minValue = v;//记录最小的负数 if (v &gt; maxValue) maxValue = v;//记录最大的正数 if (v &gt; 0) posSize++;//记录正数个数 else if (v &lt; 0) negSize++;//记录负数个数 else zeroSize++;//记录0的个数 &#125; if (zeroSize &gt;= 3)//若有3个以上的0，则0,0,0符合要求 res.add(Arrays.asList(0, 0, 0)); if (negSize == 0 || posSize == 0) return res; if (minValue * 2 + maxValue &gt; 0)//正数中大于最小负数两倍的数字一定不满足条件 maxValue = -minValue * 2; else if (maxValue * 2 + minValue &lt; 0)//负数中小于最大正数两倍的数字一定不满足条件 minValue = -maxValue * 2; int[] map = new int[maxValue - minValue + 1];//创建新的数组，采用map映射表方式记录满足条件的数字及其出现次数 int[] negs = new int[negSize];//负数数组 int[] poses = new int[posSize];//正数数组 negSize = 0; posSize = 0; for (int v : nums) &#123;//遍历原数组，将新的三个数组填值，在map中记录各数字出现次数 if (v &gt;= minValue &amp;&amp; v &lt;= maxValue) &#123; if (map[v - minValue]++ == 0) &#123; if (v &gt; 0) poses[posSize++] = v; else if (v &lt; 0) negs[negSize++] = v; &#125; &#125; &#125; Arrays.sort(poses, 0, posSize);//排序 Arrays.sort(negs, 0, negSize);//排序 int basej = 0; for (int i = negSize - 1; i &gt;= 0; i--) &#123;//循环查找map中是否存在c使得a&gt;=c&gt;=b int nv = negs[i]; int minp = (-nv) &gt;&gt;&gt; 1;//minp为所选负数nv的绝对值除以二 while (basej &lt; posSize &amp;&amp; poses[basej] &lt; minp)//若正数的值小于minp时一定不满足要求，直接跳过 basej++; for (int j = basej; j &lt; posSize; j++) &#123; int pv = poses[j]; int cv = 0 - nv - pv; if (cv &gt;= nv &amp;&amp; cv &lt;= pv) &#123;//若c在正数a与负数b之间则满足要求 if (cv == nv) &#123; if (map[nv - minValue] &gt; 1)//若c==b且b出现次数在2次以上时，即可选取a,b,b的组合满足题意 res.add(Arrays.asList(nv, nv, pv)); &#125; else if (cv == pv) &#123; if (map[pv - minValue] &gt; 1)//若c==a且a出现次数在2次以上时，即可选取a,a,b的组合满足题意 res.add(Arrays.asList(nv, pv, pv)); &#125; else &#123; if (map[cv - minValue] &gt; 0)//若c!=a且c!=b，则c只需要出现一次即可选取a,c,b的组合满足题意 res.add(Arrays.asList(nv, cv, pv)); &#125; &#125; else if (cv &lt; nv) break;//若待求数字c小于所选负数，那么之后循环中的任何正数和负数都将大于本次循环的正数与负数，c=0-a-b,c的值就会越来越小，即之后所有循环待求数字c都将小于所选负数，所以直接break &#125; &#125; return res; &#125;&#125; 我在代码中添加了注释，把算法的大致思路标出来了，大家可以逐步阅读。 若数组中有n个负数m个正数，则算法时间复杂度为O(n*m)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[遇见]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-QzIvHgXD"), narrow: false, autoplay: false, showlrc: false, music: { title: "遇见", author: "文二大佬", url: "http://tx.stream.kg.qq.com/szkge/b36845eee22f3fc93429142bc5818356934fdebd?ftnrkey=c993434e5db5c3a6e2c989b86aace47faa0d446ab279cb51fabc0c4ce406cfa412b1c6745c640462de856f79699bb930429ea644c8706684dcc6ab80d7762a4f&amp", pic: "", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>我的翻唱</category>
      </categories>
  </entry>
</search>
